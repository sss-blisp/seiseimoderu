# -*- coding: utf-8 -*-
"""拡散モデル.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rNcgu2WoKMozPOjv6zajmkQGH6sOymJn
"""

import time
import torch
import torchvision
from torch import nn
from torch.utils.data import DataLoader
from matplotlib import pyplot as plt

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(f'Using device: {device}')

dataset = torchvision.datasets.MNIST(root="/data", train=True, download=True, transform=torchvision.transforms.ToTensor())

# おっと、4が混ざりました。1か8か、あるいは4です。
# 好きな数字に変えても良いでしょう。
target_values = [0, 1, 2,3,4,5,6,7,8,9]

target_images = []
for data in dataset:
    if data[1] in target_values:
        target_images.append(data)

train_dataloader = DataLoader(target_images, batch_size=8, shuffle=True)

def corrupt(x, amount):
  """
    x : 入力する画像(複数), x.shape = torch.Size([batch_size, 1, 28, 28])
    amount : 各画像にどれだけノイズを入れるかの比率を入れたndarray, 0->そのまま, 1->完全にノイズ
  """
  noise = torch.rand_like(x)
  amount = amount.view(-1, 1, 1, 1)
  return x*(1-amount) + noise*amount

# ノイズが加わる様子を可視化
amount = torch.linspace(0, 1, x.shape[0])
noised_x = corrupt(x, amount)

_, axs = plt.subplots(2, 1, figsize=(12, 5))
axs[0].set_title('Input data')
axs[0].imshow(torchvision.utils.make_grid(x)[0], cmap='Greys')
axs[1].set_title('Corrupted data (-- amount increases -->)')
axs[1].imshow(torchvision.utils.make_grid(noised_x)[0], cmap='Greys');

class BasicUNet(nn.Module):
    def __init__(self, in_channels=1, out_channels=1):
        super().__init__()

        self.down_layer1 = nn.Conv2d(in_channels, 32, kernel_size=5, padding=2)
        self.down_layer2 = nn.Conv2d(32, 64, kernel_size=5, padding=2)
        self.down_layer3 = nn.Conv2d(64, 64, kernel_size=5, padding=2)

        self.up_layer1 = nn.Conv2d(64, 64, kernel_size=5, padding=2)
        self.up_layer2 = nn.Conv2d(64, 32, kernel_size=5, padding=2)
        self.up_layer3 = nn.Conv2d(32, out_channels, kernel_size=5, padding=2)

        self.act = nn.SiLU()
        self.downscale = nn.MaxPool2d(2)
        self.upscale = nn.Upsample(scale_factor=2)

    def forward(self, x):
        x1 = self.act(self.down_layer1(x))
        x2 = self.downscale(x1)
        x2 = self.act(self.down_layer2(x2))
        x3 = self.downscale(x2)
        x3 = self.act(self.down_layer3(x3))

        y = self.act(self.up_layer1(x3))
        y = self.upscale(y) + x2
        y = self.act(self.up_layer2(y))
        y = self.upscale(y) + x1
        y = self.act(self.up_layer3(y))
        return y

batch_size = 128
train_dataloader = DataLoader(target_images, batch_size=batch_size, shuffle=True)

max_epochs = 5

net = BasicUNet()
net.to(device)


loss_func = nn.MSELoss()
optimizer = torch.optim.Adam(net.parameters(), lr=1e-3)

t1 = time.time()

history = []
for epoch in range(max_epochs):
    for x, y in train_dataloader:
        x = x.to(device)
        # どれくらいノイズを入れるかは乱数で決める
        noise_amount = torch.rand(x.shape[0]).to(device)
        noisy_x = corrupt(x, noise_amount)

        pred = net(noisy_x)
        loss = loss_func(pred, x)

        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
        history.append(loss.item())

    avg_loss = sum(history[-len(train_dataloader):])/len(train_dataloader)
    print(f'Finished epoch {epoch}. Average loss for this epoch: {avg_loss:05f}')

time1 = time.time() - t1
plt.plot(history)
plt.ylim(0, 0.1)

n_steps = 5
x = torch.rand(8, 1, 28, 28).to(device)
step_history = [x.detach().cpu()]
pred_output_history = []

for i in range(n_steps):
    with torch.no_grad():
        pred = net(x)
    pred_output_history.append(pred.detach().cpu())

    mix_factor = 1/(n_steps - i)
    x = x*(1-mix_factor) + pred*mix_factor
    step_history.append(x.detach().cpu())

_, axs = plt.subplots(n_steps, 2, figsize=(9, 4), sharex=True)
axs[0,0].set_title('x (model input)')
axs[0,1].set_title('model prediction')
for i in range(n_steps):
    axs[i, 0].imshow(torchvision.utils.make_grid(step_history[i])[0].clip(0, 1), cmap='Greys')
    axs[i, 1].imshow(torchvision.utils.make_grid(pred_output_history[i])[0].clip(0, 1), cmap='Greys')

n_steps = 40
x = torch.rand(64, 1, 28, 28).to(device)

for i in range(n_steps):
  with torch.no_grad():
    pred = net(x)
  mix_factor = 1/(n_steps - i)
  x = x*(1-mix_factor) + pred*mix_factor

fig, ax = plt.subplots(1, 1, figsize=(12, 12))
ax.imshow(torchvision.utils.make_grid(x.detach().cpu(), nrow=8)[0].clip(0, 1), cmap='Greys')

print(time1)